"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = void 0;
var tslib_1 = require("tslib");
var get_1 = tslib_1.__importDefault(require("lodash/get"));
var subscriptions_transport_ws_1 = require("subscriptions-transport-ws");
var ws_1 = tslib_1.__importDefault(require("ws"));
var zen_observable_ts_1 = require("zen-observable-ts");
var error_1 = require("../error");
var fetcher_1 = require("../fetcher");
var chain_1 = require("./chain");
var generateGraphqlOperation_1 = require("./generateGraphqlOperation");
var createClient = function (_a) {
    var queryRoot = _a.queryRoot, mutationRoot = _a.mutationRoot, subscriptionRoot = _a.subscriptionRoot, options = tslib_1.__rest(_a, ["queryRoot", "mutationRoot", "subscriptionRoot"]);
    var fetcher = fetcher_1.createFetcher(options);
    var client = {};
    if (queryRoot) {
        client.query = function (request) {
            if (!queryRoot)
                throw new Error('queryRoot argument is missing');
            var resultPromise = fetcher(generateGraphqlOperation_1.generateGraphqlOperation('query', queryRoot, request));
            return resultPromise;
        };
    }
    if (mutationRoot) {
        client.mutation = function (request) {
            if (!mutationRoot)
                throw new Error('mutationRoot argument is missing');
            var resultPromise = fetcher(generateGraphqlOperation_1.generateGraphqlOperation('mutation', mutationRoot, request));
            return resultPromise;
        };
    }
    if (subscriptionRoot) {
        client.subscription = function (request) {
            if (!subscriptionRoot) {
                throw new Error('subscriptionRoot argument is missing');
            }
            var op = generateGraphqlOperation_1.generateGraphqlOperation('subscription', subscriptionRoot, request);
            if (!client.wsClient) {
                client.wsClient = getSubscriptionClient(options);
            }
            var obs = new zen_observable_ts_1.Observable(function (observer) {
                // TODO check that unsubscribing wrapper obs calls unsubscribe on the wrapped one
                var obs = client.wsClient.request(op).subscribe({
                    next: function (x) {
                        // if (observer.closed) return
                        observer.next(x);
                    },
                    error: function (x) {
                        // if (observer.closed) return
                        observer.error(x);
                    },
                    complete: function () {
                        observer.complete();
                    },
                });
                return function () {
                    obs.unsubscribe();
                };
            }).map(function (val) {
                var _a;
                if ((_a = val === null || val === void 0 ? void 0 : val.errors) === null || _a === void 0 ? void 0 : _a.length) {
                    throw new error_1.ClientError(val === null || val === void 0 ? void 0 : val.errors);
                }
                return val === null || val === void 0 ? void 0 : val.data;
            });
            return obs;
        };
    }
    client.chain = {
        query: chain_1.chain(function (path, request, defaultValue) {
            return client.query(request).then(mapResponse(path, defaultValue));
        }),
        mutation: chain_1.chain(function (path, request, defaultValue) {
            return client.mutation(request).then(mapResponse(path, defaultValue));
        }),
        subscription: chain_1.chain(function (path, request, defaultValue) {
            var obs = client.subscription(request);
            var mapper = mapResponse(path, defaultValue);
            return zen_observable_ts_1.Observable.from(obs).map(mapper);
        }),
    };
    return client;
};
exports.createClient = createClient;
var mapResponse = function (path, defaultValue) {
    if (defaultValue === void 0) { defaultValue = undefined; }
    return function (response) {
        var result = get_1.default(response, tslib_1.__spreadArrays(path), defaultValue);
        if (result === undefined) {
            throw new Error("Response path `" + path.join('.') + "` is empty");
        }
        return result;
    };
};
function getSubscriptionClient(opts) {
    var _this = this;
    if (opts === void 0) { opts = {}; }
    var _a = opts.subscription || {}, url = _a.url, _b = _a.headers, headers = _b === void 0 ? {} : _b;
    // by default use the top level url
    if (!url) {
        url = opts === null || opts === void 0 ? void 0 : opts.url;
    }
    if (!url) {
        throw new Error('Subscription client error: missing url parameter');
    }
    return new subscriptions_transport_ws_1.SubscriptionClient(url, tslib_1.__assign({ lazy: true, reconnect: true, reconnectionAttempts: 3, connectionParams: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var headersObject, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(typeof headers == 'function')) return [3 /*break*/, 2];
                        return [4 /*yield*/, headers()];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = headers;
                        _b.label = 3;
                    case 3:
                        headersObject = _a;
                        headersObject = headersObject || {};
                        return [2 /*return*/, {
                                headers: headersObject,
                            }];
                }
            });
        }); } }, opts), typeof window === 'undefined' ? ws_1.default : undefined);
}
//# sourceMappingURL=createClient.js.map
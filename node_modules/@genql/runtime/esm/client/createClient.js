import { __assign, __awaiter, __generator, __rest, __spreadArrays } from "tslib";
import get from 'lodash/get';
import { SubscriptionClient as WsSubscriptionClient, } from 'subscriptions-transport-ws';
import ws from 'ws';
import { Observable } from 'zen-observable-ts';
import { ClientError } from '../error';
import { createFetcher } from '../fetcher';
import { chain } from './chain';
import { generateGraphqlOperation, } from './generateGraphqlOperation';
export var createClient = function (_a) {
    var queryRoot = _a.queryRoot, mutationRoot = _a.mutationRoot, subscriptionRoot = _a.subscriptionRoot, options = __rest(_a, ["queryRoot", "mutationRoot", "subscriptionRoot"]);
    var fetcher = createFetcher(options);
    var client = {};
    if (queryRoot) {
        client.query = function (request) {
            if (!queryRoot)
                throw new Error('queryRoot argument is missing');
            var resultPromise = fetcher(generateGraphqlOperation('query', queryRoot, request));
            return resultPromise;
        };
    }
    if (mutationRoot) {
        client.mutation = function (request) {
            if (!mutationRoot)
                throw new Error('mutationRoot argument is missing');
            var resultPromise = fetcher(generateGraphqlOperation('mutation', mutationRoot, request));
            return resultPromise;
        };
    }
    if (subscriptionRoot) {
        client.subscription = function (request) {
            if (!subscriptionRoot) {
                throw new Error('subscriptionRoot argument is missing');
            }
            var op = generateGraphqlOperation('subscription', subscriptionRoot, request);
            if (!client.wsClient) {
                client.wsClient = getSubscriptionClient(options);
            }
            var obs = new Observable(function (observer) {
                // TODO check that unsubscribing wrapper obs calls unsubscribe on the wrapped one
                var obs = client.wsClient.request(op).subscribe({
                    next: function (x) {
                        // if (observer.closed) return
                        observer.next(x);
                    },
                    error: function (x) {
                        // if (observer.closed) return
                        observer.error(x);
                    },
                    complete: function () {
                        observer.complete();
                    },
                });
                return function () {
                    obs.unsubscribe();
                };
            }).map(function (val) {
                var _a;
                if ((_a = val === null || val === void 0 ? void 0 : val.errors) === null || _a === void 0 ? void 0 : _a.length) {
                    throw new ClientError(val === null || val === void 0 ? void 0 : val.errors);
                }
                return val === null || val === void 0 ? void 0 : val.data;
            });
            return obs;
        };
    }
    client.chain = {
        query: chain(function (path, request, defaultValue) {
            return client.query(request).then(mapResponse(path, defaultValue));
        }),
        mutation: chain(function (path, request, defaultValue) {
            return client.mutation(request).then(mapResponse(path, defaultValue));
        }),
        subscription: chain(function (path, request, defaultValue) {
            var obs = client.subscription(request);
            var mapper = mapResponse(path, defaultValue);
            return Observable.from(obs).map(mapper);
        }),
    };
    return client;
};
var mapResponse = function (path, defaultValue) {
    if (defaultValue === void 0) { defaultValue = undefined; }
    return function (response) {
        var result = get(response, __spreadArrays(path), defaultValue);
        if (result === undefined) {
            throw new Error("Response path `" + path.join('.') + "` is empty");
        }
        return result;
    };
};
function getSubscriptionClient(opts) {
    var _this = this;
    if (opts === void 0) { opts = {}; }
    var _a = opts.subscription || {}, url = _a.url, _b = _a.headers, headers = _b === void 0 ? {} : _b;
    // by default use the top level url
    if (!url) {
        url = opts === null || opts === void 0 ? void 0 : opts.url;
    }
    if (!url) {
        throw new Error('Subscription client error: missing url parameter');
    }
    return new WsSubscriptionClient(url, __assign({ lazy: true, reconnect: true, reconnectionAttempts: 3, connectionParams: function () { return __awaiter(_this, void 0, void 0, function () {
            var headersObject, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(typeof headers == 'function')) return [3 /*break*/, 2];
                        return [4 /*yield*/, headers()];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = headers;
                        _b.label = 3;
                    case 3:
                        headersObject = _a;
                        headersObject = headersObject || {};
                        return [2 /*return*/, {
                                headers: headersObject,
                            }];
                }
            });
        }); } }, opts), typeof window === 'undefined' ? ws : undefined);
}
//# sourceMappingURL=createClient.js.map
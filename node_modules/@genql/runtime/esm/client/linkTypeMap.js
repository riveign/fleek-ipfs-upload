import { __spreadArrays } from "tslib";
import assign from 'lodash/assign';
export var linkTypeMap = function (typeMap) {
    var indexToName = assign.apply(void 0, __spreadArrays([{}], Object.keys(typeMap.types).map(function (k, i) {
        var _a;
        return (_a = {}, _a[i] = k, _a);
    })));
    // add the name value
    var intermediaryTypeMap = assign.apply(void 0, __spreadArrays([{}], Object.keys(typeMap.types || {}).map(function (k) {
        var _a;
        var type = typeMap.types[k];
        var fields = type || {};
        // processFields(fields, indexToName)
        return _a = {},
            _a[k] = {
                name: k,
                // type scalar properties
                scalar: Object.keys(fields).filter(function (f) {
                    var type = (fields[f] || [])[0];
                    return typeMap.scalars.includes(type);
                }),
                // fields with corresponding `type` and `args`
                fields: assign.apply(void 0, __spreadArrays([{}], Object.keys(fields).map(function (f) {
                    var _a;
                    var _b = fields[f] || [], typeIndex = _b[0], args = _b[1];
                    return _a = {},
                        _a[f] = {
                            // replace index with type name
                            type: indexToName[typeIndex],
                            args: assign.apply(void 0, __spreadArrays([{}], Object.keys(args || {}).map(function (k) {
                                var _a;
                                // if argTypeString == argTypeName, argTypeString is missing, need to readd it
                                var _b = args[k], argTypeName = _b[0], argTypeString = _b[1];
                                return _a = {},
                                    _a[k] = [
                                        indexToName[argTypeName],
                                        argTypeString ||
                                            indexToName[argTypeName],
                                    ],
                                    _a;
                            }))),
                        },
                        _a;
                }))),
            },
            _a;
    })));
    var res = resolveConcreteTypes(intermediaryTypeMap);
    return res;
};
// replace typename with concrete type
export var resolveConcreteTypes = function (linkedTypeMap) {
    Object.keys(linkedTypeMap).forEach(function (typeNameFromKey) {
        var type = linkedTypeMap[typeNameFromKey];
        // type.name = typeNameFromKey
        if (!type.fields) {
            return;
        }
        var fields = type.fields;
        Object.keys(fields).forEach(function (f) {
            var field = fields[f];
            if (field.args) {
                var args_1 = field.args;
                Object.keys(args_1).forEach(function (key) {
                    var arg = args_1[key];
                    if (arg) {
                        var typeName_1 = arg[0];
                        if (typeof typeName_1 === 'string') {
                            if (!linkedTypeMap[typeName_1]) {
                                linkedTypeMap[typeName_1] = { name: typeName_1 };
                            }
                            arg[0] = linkedTypeMap[typeName_1];
                        }
                    }
                });
            }
            var typeName = field.type;
            if (typeof typeName === 'string') {
                if (!linkedTypeMap[typeName]) {
                    linkedTypeMap[typeName] = { name: typeName };
                }
                field.type = linkedTypeMap[typeName];
            }
        });
    });
    return linkedTypeMap;
};
//# sourceMappingURL=linkTypeMap.js.map
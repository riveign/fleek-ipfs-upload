import { __spreadArrays } from "tslib";
import { getFieldFromPath } from './getFieldFromPath';
var parseRequest = function (request, ctx, path) {
    if (Array.isArray(request)) {
        var args_1 = request[0], fields = request[1];
        var argNames = Object.keys(args_1);
        if (argNames.length === 0) {
            return parseRequest(fields, ctx, path);
        }
        var field_1 = getFieldFromPath(ctx.root, path);
        return "(" + argNames.map(function (argName) {
            ctx.varCounter++;
            var varName = "v" + ctx.varCounter;
            var typing = field_1.args && field_1.args[argName]; // typeMap used here, .args
            if (!typing) {
                throw new Error("no typing defined for argument `" + argName + "` in path `" + path.join('.') + "`");
            }
            ctx.variables[varName] = {
                value: args_1[argName],
                typing: typing,
            };
            return argName + ":$" + varName;
        }) + ")" + parseRequest(fields, ctx, path);
    }
    else if (typeof request === 'object') {
        var fields_1 = request;
        var fieldNames = Object.keys(fields_1).filter(function (k) { return Boolean(fields_1[k]); });
        if (fieldNames.length === 0) {
            // TODO if fields are empty just return?
            throw new Error('field selection should not be empty');
        }
        var type = path.length > 0 ? getFieldFromPath(ctx.root, path).type : ctx.root;
        var scalarFields = type.scalar;
        var scalarFieldsFragment = void 0;
        if (fieldNames.includes('__scalar')) {
            var falsyFieldNames_1 = new Set(Object.keys(fields_1).filter(function (k) { return !Boolean(fields_1[k]); }));
            if (scalarFields === null || scalarFields === void 0 ? void 0 : scalarFields.length) {
                ctx.fragmentCounter++;
                scalarFieldsFragment = "f" + ctx.fragmentCounter;
                ctx.fragments.push("fragment " + scalarFieldsFragment + " on " + type.name + "{" + scalarFields
                    .filter(function (f) { return !falsyFieldNames_1.has(f); })
                    .join(',') + "}");
            }
        }
        var fieldsSelection = fieldNames
            .filter(function (f) { return !['__scalar', '__name'].includes(f); })
            .map(function (f) {
            var parsed = parseRequest(fields_1[f], ctx, __spreadArrays(path, [f]));
            if (f.startsWith('on_')) {
                ctx.fragmentCounter++;
                var implementationFragment = "f" + ctx.fragmentCounter;
                var typeMatch = f.match(/^on_(.+)/);
                if (!typeMatch || !typeMatch[1])
                    throw new Error('match failed');
                ctx.fragments.push("fragment " + implementationFragment + " on " + typeMatch[1] + parsed);
                return "..." + implementationFragment;
            }
            else {
                return "" + f + parsed;
            }
        })
            .concat(scalarFieldsFragment ? ["..." + scalarFieldsFragment] : [])
            .join(',');
        return "{" + fieldsSelection + "}";
    }
    else {
        return '';
    }
};
export var generateGraphqlOperation = function (operation, root, fields) {
    var ctx = {
        root: root,
        varCounter: 0,
        variables: {},
        fragmentCounter: 0,
        fragments: [],
    };
    var result = parseRequest(fields, ctx, []);
    var varNames = Object.keys(ctx.variables);
    var varsString = varNames.length > 0
        ? "(" + varNames.map(function (v) {
            var variableType = ctx.variables[v].typing[1];
            //   console.log('variableType', variableType)
            return "$" + v + ":" + variableType;
        }) + ")"
        : '';
    var operationName = (fields === null || fields === void 0 ? void 0 : fields.__name) || '';
    return {
        query: __spreadArrays([
            operation + " " + operationName + varsString + result
        ], ctx.fragments).join(','),
        variables: Object.keys(ctx.variables).reduce(function (r, v) {
            r[v] = ctx.variables[v].value;
            return r;
        }, {}),
    };
};
//# sourceMappingURL=generateGraphqlOperation.js.map